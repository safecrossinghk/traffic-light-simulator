<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>å³æ™‚é™„è¿‘äººæµæŸ¥è©¢</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
font-family: Arial, sans-serif;
text-align: center;
font-size: 1.2em;
background-color: #f0f0f0;
margin: 0;
padding: 0;
}
#map {
height: 300px;
width: 100%;
margin: auto;
border: 1px solid #999;
}
#crowdStatus {
margin: 15px;
font-weight: bold;
}
button {
font-size: 1em;
padding: 10px 20px;
margin: 10px;
border: none;
background-color: #007BFF;
color: white;
border-radius: 6px;
}
button:hover {
background-color: #0056b3;
}
</style>
</head>
<body>
<h1>å³æ™‚é™„è¿‘äººæµæŸ¥è©¢</h1>
<p id="crowdStatus">æ­£åœ¨å–å¾—è³‡æ–™...</p>
<div id="map"></div>
<div>
<button onclick="speak('zh')">ğŸ“¢ ç²µèªèªéŸ³</button>
<button onclick="speak('en')">ğŸ”Š English Audio</button>
</div>

<script>
const apiKey = "MWE3NWNmMzFjZWNiNGMxMDlhNGNhNDFjNTY3ZjZkMTB8NzY5ZGY0MGQ0Zg";
const places = [
"æ—ºè§’ç«™", "å°–æ²™å’€æµ·æ¸¯åŸ", "éŠ…é‘¼ç£æ™‚ä»£å»£å ´", "ä¸Šç’°æ¸¯æ¾³ç¢¼é ­",
"ç´…ç£¡éæµ·éš§é“", "ä¸­ç’°ç¢¼é ­", "æ·±æ°´åŸ—ç¦æ¦®è¡—", "æ²™ç”°æ–°åŸå¸‚å»£å ´"
];

let map, marker;
let zhText = "", enText = "";

function speak(lang) {
const utterance = new SpeechSynthesisUtterance(lang === 'zh' ? zhText : enText);
utterance.lang = lang === 'zh' ? 'zh-HK' : 'en-US';
speechSynthesis.cancel(); // åœæ­¢å‰ä¸€æ®µèªéŸ³
speechSynthesis.speak(utterance);
}

function initMap() {
navigator.geolocation.getCurrentPosition((pos) => {
const latlng = { lat: pos.coords.latitude, lng: pos.coords.longitude };
map = new google.maps.Map(document.getElementById("map"), {
center: latlng,
zoom: 13,
});
marker = new google.maps.Marker({ position: latlng, map: map });

fetchAllPlaces();
setInterval(fetchAllPlaces, 5 * 60 * 1000); // æ¯ 5 åˆ†é˜æ›´æ–°
});
}

function fetchAllPlaces() {
document.getElementById("crowdStatus").innerText = "æ­£åœ¨å–å¾—è³‡æ–™...";
const promises = places.map(name => fetchPlaceCrowd(name));
Promise.all(promises).then(() => {
console.log("å…¨éƒ¨åœ°é»æŸ¥è©¢å®Œæˆ");
});
}

async function fetchPlaceCrowd(name) {
const url = `https://api.app.outscraper.com/maps/search-v2?query=${encodeURIComponent(name)}&limit=1&lang=zh-tw&region=hk`;

try {
const res = await fetch(url, {
headers: {
"X-API-KEY": apiKey,
"Content-Type": "application/json"
}
});
const data = await res.json();
const place = data[0];

if (!place) return;

const pop = place.current_popularity;
if (typeof pop === "number") {
let zh, en;
if (pop >= 70) {
zh = `${name}äººæµç¹å¿™ï¼Œè«‹å°å¿ƒå‰å¾€ã€‚`;
en = `${name} is crowded. Please be cautious.`;
} else if (pop >= 30) {
zh = `${name}äººæµé©ä¸­ï¼Œè«‹ä¿æŒè­¦è¦ºã€‚`;
en = `${name} is moderately busy. Stay alert.`;
} else {
zh = `${name}äººæµä¸ç¹å¿™ï¼Œè«‹å®‰å¿ƒå‰å¾€ã€‚`;
en = `${name} is not crowded. You may proceed.`;
}
document.getElementById("crowdStatus").innerText = zh;
zhText = zh;
enText = en;
} else {
const zh = `${name}åƒ…æä¾›æ­·å²äººæµè³‡æ–™ã€‚`;
const en = `Only historical data available for ${name}.`;
document.getElementById("crowdStatus").innerText = zh;
zhText = zh;
enText = en;
}

map.setCenter({ lat: place.coords_lat, lng: place.coords_lng });
marker.setPosition({ lat: place.coords_lat, lng: place.coords_lng });

} catch (err) {
console.error("éŒ¯èª¤ï¼š", err);
document.getElementById("crowdStatus").innerText = `ç„¡æ³•å–å¾—${name}è³‡æ–™ã€‚`;
}
}
</script>

<script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyC5EiwICC0wjVsscauKVrHhlA8tDMG1jPY&callback=initMap"></script>
</body>
</html>