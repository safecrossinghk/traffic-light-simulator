<!DOCTYPE html>
<html lang="zh-HK">
<head>
<meta charset="UTF-8" />
<title>é¦™æ¸¯é›¨é‡è‡¨è¿‘é æ¸¬</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
<style>
body { font-family: sans-serif; text-align: center; background: #eef6ff; margin: 0; padding: 0; }
#map { height: 300px; width: 90%; margin: 10px auto; border-radius: 10px; }
.status { margin-top: 10px; font-size: 16px; }
.loading { color: #555; }
.error { color: red; }
.success { color: green; font-weight: bold; }
</style>
</head>
<body>
<h2>â˜” é¦™æ¸¯é›¨é‡è‡¨è¿‘é æ¸¬</h2>
<div id="map"></div>
<div class="status loading" id="status">ğŸ“ æ­£åœ¨å®šä½ä¸­...</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
const fallbackLocation = { lat: 22.3364, lon: 114.1488 }; // è”æè§’
const statusEl = document.getElementById('status');
let map, marker;

function speak(text) {
const utterance = new SpeechSynthesisUtterance(text);
utterance.lang = 'zh-HK';
speechSynthesis.speak(utterance);
}

function updateStatus(msg, className = "loading") {
statusEl.textContent = msg;
statusEl.className = `status ${className}`;
}

function fetchWithTimeout(resource, options = {}) {
const { timeout = 10000 } = options;
const controller = new AbortController();
const id = setTimeout(() => controller.abort(), timeout);
return fetch(resource, {
...options,
signal: controller.signal
}).finally(() => clearTimeout(id));
}

function fetchRainForecast(lat, lon, retryCount = 0) {
const workerURL = `https://crowdtest6br2.ctakwah.workers.dev/?lat=${lat}&lon=${lon}`;
updateStatus("ğŸŒ§ï¸ æ­£åœ¨è¼‰å…¥é æ¸¬è³‡æ–™...", "loading");

fetchWithTimeout(workerURL, { timeout: 10000 })
.then(res => {
if (!res.ok) throw new Error(`Worker éŒ¯èª¤ä»£ç¢¼ ${res.status}`);
return res.json();
})
.then(data => {
if (data.rainExpected) {
updateStatus(`âš ï¸ ${data.message}ï¼ˆ${data.immediateRain} mmï¼‰`, "success");
} else {
updateStatus(`âœ… ${data.message}`, "success");
}
})
.catch(err => {
if (retryCount < 2) {
updateStatus(`ğŸ” å˜—è©¦é‡æ–°å–å¾—è³‡æ–™ä¸­...`, "loading");
setTimeout(() => fetchRainForecast(lat, lon, retryCount + 1), 2000);
} else {
updateStatus(`âš ï¸ ç„¡æ³•å–å¾—é æ¸¬è³‡æ–™ï¼š${err.message}`, "error");
}
});
}

function initMapAndForecast(lat, lon) {
map = L.map('map').setView([lat, lon], 14);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
maxZoom: 19
}).addTo(map);

marker = L.marker([lat, lon]).addTo(map)
.bindPopup("ä½ çš„ä½ç½®").openPopup();

fetchRainForecast(lat, lon);
}

function onSuccess(position) {
const lat = position.coords.latitude;
const lon = position.coords.longitude;
updateStatus(`âœ… å·²å–å¾—ä½ç½®ï¼š${lat.toFixed(5)}, ${lon.toFixed(5)}`, "success");
initMapAndForecast(lat, lon);
}

function onError(error) {
updateStatus("âŒ æœªèƒ½å–å¾—å®šä½ï¼Œä½¿ç”¨é è¨­åœ°é»ï¼ˆè”æè§’ï¼‰", "error");
speak("è«‹å…è¨±å®šä½æ¬Šé™ã€‚ç¾æ™‚ä½¿ç”¨é è¨­åœ°é»ã€‚");
initMapAndForecast(fallbackLocation.lat, fallbackLocation.lon);
}

// è‡ªå‹•è«‹æ±‚å®šä½
if ("geolocation" in navigator) {
navigator.geolocation.getCurrentPosition(onSuccess, onError, {
enableHighAccuracy: true,
timeout: 5000
});
} else {
updateStatus("âŒ æ­¤ç€è¦½å™¨ä¸æ”¯æ´å®šä½åŠŸèƒ½", "error");
speak("æ‚¨çš„è£ç½®ä¸æ”¯æ´å®šä½åŠŸèƒ½");
initMapAndForecast(fallbackLocation.lat, fallbackLocation.lon);
}
</script>
</body>
</html>